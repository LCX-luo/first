# 写在前面

为什么js需要使用axios，async的函数？

要理解 “为什么 C 语言不需要`await`、默认等待函数完成”，核心在于**C 语言是 “同步阻塞式” 语言，而 JavaScript 是 “异步非阻塞式” 语言**—— 两者的执行模型完全不同，导致对 “函数等待” 的处理逻辑存在本质差异。

### 1. 先明确核心概念：同步 vs 异步

在解释两种语言的差异前，先理清最关键的区别：

- **同步执行**：代码按顺序一行一行执行，**前一个函数没执行完，后一个函数绝对不开始**（函数执行会 “阻塞” 后续代码）。
- **异步执行**：代码执行到 “耗时操作”（如网络请求、文件读取）时，会 “挂起” 这个操作，先继续执行后面的代码；等耗时操作完成后，再回头处理它的结果（不会阻塞后续代码）。

### 2. C 语言：天生同步阻塞，无需`await`

C 语言的设计初衷是处理**CPU 密集型、顺序化任务**（如算法计算、硬件操作），其执行模型是 “同步阻塞” 的 ——**所有函数默认都是 “等待完成后再往下走”**，根本不存在 “函数没执行完就跳走” 的情况，因此不需要`await`这类关键字。

举个 C 语言的例子：

```c
#include <stdio.h>
#include <unistd.h> // 包含 sleep 函数

// 模拟一个耗时函数（如文件读取、硬件操作）
void slowFunction() {
    printf("开始执行耗时操作...\n");
    sleep(3); // 暂停3秒（模拟耗时）
    printf("耗时操作完成！\n");
}

int main() {
    printf("第一步：执行前的准备\n");
    slowFunction(); // 调用耗时函数——C会“默认等待”它执行完
    printf("第二步：耗时函数完成后，才执行这行\n"); // 3秒后才会打印
    return 0;
}
```

**执行结果**：
“第一步” → 等待 3 秒 → “耗时操作完成” → “第二步”
这里`slowFunction`执行时，`main`函数会被 “阻塞”，直到`slowFunction`完全结束，才会继续执行`printf("第二步...")`—— 这是 C 语言的默认行为，不需要任何额外关键字（如`await`）来 “强制等待”。

### 3. JavaScript：异步非阻塞，必须用`await`控制等待

JavaScript 的设计初衷是**在浏览器中处理用户交互（如点击、输入）和网络请求**—— 如果像 C 语言一样 “同步阻塞”，会导致严重问题：

- 比如发送一个网络请求需要 3 秒，若 JS 同步等待，这 3 秒内浏览器会 “卡死”（无法响应点击、无法渲染页面），用户体验极差。

因此 JS 采用 “异步非阻塞” 模型：**遇到耗时操作（如`axios`请求、`setTimeout`），会先 “挂起” 这个操作，继续执行后面的代码**；等耗时操作完成后，再通过 “回调” 或 “Promise” 处理结果。

但这种模型会带来一个问题：如果我们需要 “等耗时操作完成后再执行后续逻辑”（比如登录请求成功后再显示欢迎页），单纯的异步逻辑会导致代码 “乱序”。例如：

```javascript
// 不使用 await 的错误示例
function login() {
    console.log("开始登录请求...");
    // axios 请求是异步的，会被“挂起”，先执行后面的代码
    axios.post("/login", { username: "a" }).then(res => {
        console.log("登录成功！");
    });
    console.log("请求还没完成，就执行这行了？"); // 会先打印这行！
}
login();
```

**执行结果**：
“开始登录请求...” → “请求还没完成，就执行这行了？” → （3 秒后）“登录成功！”
这显然不符合 “登录成功后再做后续操作” 的逻辑 —— 此时就需要`await`来 “强制让 JS 等待异步操作完成，再继续执行”。

### 4. 本质差异：执行模型决定是否需要`await`

两种语言的核心区别可以总结为下表：

| 维度                  | C 语言                           | JavaScript                              |
| --------------------- | -------------------------------- | --------------------------------------- |
| 执行模型              | 同步阻塞                         | 异步非阻塞（浏览器 / Node.js 环境）     |
| 函数执行默认行为      | 必须等待函数完成，再执行后续代码 | 耗时函数会被 “挂起”，先执行后续代码     |
| 是否需要 “等待关键字” | 不需要（默认就是等待）           | 需要`await`（强制让异步操作按顺序执行） |
| 核心目的              | 保证 CPU 密集型任务的顺序性      | 保证用户交互 / 网络请求时的页面响应性   |

### 总结

C 语言不需要`await`，是因为它的**同步阻塞模型默认会 “等待函数完成”**，不存在 “函数没执行完就跳走” 的情况；而 JavaScript 需要`await`，是因为它的**异步非阻塞模型会 “跳过耗时操作”**，`await`的作用是 “打破这种默认的异步逻辑，强制按顺序等待”—— 两者的差异本质是 “语言设计目标和执行模型” 的不同，而非 “功能缺失”。



# 前端实现

#### 一、axios

##### 1.引入

<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>

用来引入axios库，可以在网页中直接使用 Axios 而无需本地安装

##### 2. 基本请求结构

```javascript
// 通用语法
axios({
  method: '请求方法',  // get/post/put/delete 等
  url: '请求地址',     // 后端接口 URL
  data: { ... },       // POST/PUT 等请求的数据（放在请求体）
  params: { ... }      // GET 请求的查询参数（拼接在 URL 后）
})
axios.post('url', data);//简化写法
.then(response => {
  // 请求成功的处理
})
.catch(error => {
  // 请求失败的处理
});
```

##### 3. 常用请求方法（简化写法）

```javascript
// 1. GET 请求（获取数据）
axios.get('/api/users', {
  params: { id: 123 }  // 会被拼接到 URL：/api/users?id=123
})
.then(res => console.log(res.data))
.catch(err => console.error(err));

// 2. POST 请求（提交数据）
axios.post('/api/login', {
  username: 'admin',
  password: '123456'
})
.then(res => console.log(res.data))
.catch(err => console.error(err));
```

#### 二、async/await 详解

`async/await` 是 JavaScript 处理异步操作的语法糖，让异步代码更像同步代码。

##### 1. 基本语法结构

```javascript
// 1. 用 async 声明异步函数
async function 函数名() {
  try {
    // 2. 用 await 等待 Promise 完成
    const 结果 = await 异步操作;  // 异步操作必须返回 Promise
    // 后续代码会等待 await 完成后执行
  } catch (error) {
    // 3. 捕获异步操作的错误
  }
}
```

##### 2. 核心特性

- `async` 函数的返回值自动包装为 Promise 对象
- `await` 只能在 `async` 函数内部使用
- `await` 会暂停代码执行，直到后面的 Promise 状态变为 `resolved`（成功）或 `rejected`（失败）
- 失败的 Promise 会抛出异常，必须用 `try/catch` 捕获

#### 三、Axios 与 async/await 结合使用（实战示例）

以下是登录功能的完整拆解：

```javascript
// 1. 给表单绑定 submit 事件，事件处理函数用 async 声明
document.getElementById('loginForm').addEventListener('submit', async function (e) {
  
  // 阻止表单默认提交行为
  e.preventDefault();

  // 2. 获取表单数据
  const username = document.getElementById('username').value;
  const password = document.getElementById('password').value;
  const messageDiv = document.getElementById('message');

  try {
    // 3. 用 await 等待 Axios 请求完成（Axios 会返回 Promise）
    const response = await axios.post(
      'http://127.0.0.1:3000/submit',  // 请求地址
      { username, password }          // 请求数据（等价于 {username: username, password: password}）
    );

    // 4. 请求成功后的处理（只有当请求成功才会执行这里）
    messageDiv.textContent = response.data.message;  // 显示后端返回的消息
    messageDiv.className = 'message success';        // 设置成功样式
    document.getElementById('loginSection').style.display = 'none';  // 隐藏登录框
    document.getElementById('dashboard').style.display = 'block';    // 显示欢迎页

  } catch (error) {
    // 5. 请求失败的处理（网络错误或后端返回 4xx/5xx 状态码时执行）
    const errorMessage = error.response?.data?.message || '登录失败，请重试';
    messageDiv.textContent = errorMessage;  // 显示错误信息
    messageDiv.className = 'message error';  // 设置错误样式
  }
});
```

##### 代码执行流程：

1. 用户点击提交按钮，触发 `submit` 事件
2. 执行 `e.preventDefault()` 阻止页面刷新
3. 获取用户名和密码
4. 发送 POST 请求到后端，并**暂停等待**响应
5. 如果响应成功（状态码 2xx）：执行 `try` 块内后续代码
6. 如果响应失败（网络错误或状态码 4xx/5xx）：跳转到 `catch` 块处理错误

#### 四、关键注意点

1. **错误处理**：
   - Axios 只有在网络错误或超时才会直接报错
   - 对于 404/500 等 HTTP 错误状态码，需要通过 `error.response.status` 判断
   - `error.response?.data?.message` 中的 `?.` 是可选链操作符，防止 `error.response` 为 `undefined` 时报错
2. **简洁写法**：
   - 当对象的属性名和变量名相同时，`{username: username}` 可简写为 `{username}`
3. **与 Promise 对比**：
   - 传统 `.then()` 写法容易产生嵌套（回调地狱）
   - `async/await` 让代码线性执行，逻辑更清晰

通过这种组合，既能利用 Axios 便捷的 HTTP 请求能力，又能通过 `async/await` 写出更易读、易维护的异步代码。

# 后端实现

## 一、核心框架与依赖导入

### 1.1 Express 框架

- **作用**：Express 是 Node.js 生态中最流行的 Web 开发框架，用于快速构建 HTTP 服务器、定义路由、处理请求与响应，简化后端开发流程。

- 导入与实例化

  ```javascript
  const express = require('express'); // 导入Express模块
  const app = express(); // 创建Express应用实例，后续通过app操作服务器
  ```

- **核心特性**：轻量级、中间件机制灵活、路由系统简洁，支持扩展多种功能（如跨域、数据解析）。

### 1.2 body-parser 中间件

- **作用**：解析 HTTP 请求体中的数据（如 JSON 格式、表单格式），将解析后的数据挂载到 `req.body` 上，方便后续业务逻辑使用。

- 导入与配置

  ```javascript
  const bodyParser = require('body-parser');
  // 解析JSON格式请求体
  app.use(bodyParser.json());
  // 解析URL编码的表单数据（extended: true支持嵌套对象结构）
  app.use(bodyParser.urlencoded({ extended: true }));
  ```

- **注意事项**：Express 4.16+ 版本已内置类似功能，可替换为 `app.use(express.json())` 和 `app.use(express.urlencoded({ extended: true }))`，无需额外安装 body-parser。

## 二、中间件机制

### 2.1 中间件概念

- 中间件是 Express 的核心机制，本质是一个函数，可访问 `req`（请求对象）、`res`（响应对象）和 `next`（下一个中间件函数），用于执行预处理逻辑、修改请求 / 响应、处理错误等。
- 执行流程：请求到达服务器后，按中间件定义顺序依次执行，调用 `next()` 可将请求传递给下一个中间件或路由；若不调用 `next()`，请求会被阻塞在当前中间件。

### 2.2 自定义跨域中间件（CORS）

- **跨域问题产生**：浏览器的同源策略限制（协议、域名、端口任一不同即为跨域），前端无法直接访问跨域后端接口，需后端配置 CORS 允许跨域请求。

- 实现代码

  ```javascript
  app.use((req, res, next) => {
    // 允许所有来源访问（生产环境建议指定具体域名，如 'http://localhost:5500'）
    res.setHeader('Access-Control-Allow-Origin', '*');
    // 允许的HTTP请求方法
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    // 允许的请求头（如Content-Type、Authorization等）
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    next(); // 传递请求到下一个中间件/路由
  });
  ```

- 关键响应头说明

  ：

  - `Access-Control-Allow-Origin`：指定允许跨域的前端域名，`*` 表示允许所有（不支持带 Cookie 的请求）。
  - `Access-Control-Allow-Methods`：明确允许的请求方法，避免浏览器预检请求失败。
  - `Access-Control-Allow-Headers`：允许前端发送的自定义请求头，需与前端实际发送的头匹配。

## 三、路由与请求处理

### 3.1 路由基础

- **定义**：路由是请求路径（URL）、请求方法（HTTP Method）与处理函数的映射关系，用于指定 “客户端发送什么请求，服务器执行什么逻辑”。

- Express 路由格式

  ```javascript
app.METHOD(PATH, HANDLER);
  // METHOD：HTTP请求方法（如get、post、put、delete）
// PATH：服务器端的请求路径（如 '/submit'、'/user'）
  // HANDLER：请求处理函数，接收req和res参数
```

### 3.2 POST 路由实战（登录逻辑为例）

#### 3.2.1 请求参数获取

- 

  ```
req.body
  ```
  
  获取前端传递的请求体数据（需先配置 body-parser 或内置解析中间件），支持解构赋值简化代码：

  ```javascript
// 从req.body中提取username和password，并重命名password为hashedPassword
  const { username, password: hashedPassword } = req.body;
```

#### 3.2.2 业务逻辑处理

- 数据校验 / 匹配

  ：通过数组方法（如

  ```
  find()
  ```
  
  ）查询数据，判断请求参数是否符合预期（如用户名、密码是否匹配）：

  ```javascript
  // 模拟从用户列表中查找匹配的用户名和密码哈希
  const matchedUser = users.find(user => 
    user.username === username && user.hashedpassword === hashedPassword
  );
  ```
  
- **`Array.find()` 方法**：遍历数组，返回第一个满足条件的元素；若无匹配元素，返回 `undefined`，常用于 “查找单个符合条件的数据” 场景。

#### 3.2.3 响应发送

- 通过

  ```
res.json()
  ```
  
  发送 JSON 格式响应，结合

  ```
res.status()
  ```

  设置 HTTP 状态码，明确告知前端请求结果：

  ```javascript
  if (matchedUser) {
    // 成功：状态码200（默认），返回成功标识和数据
  res.json({ code: 200, username: matchedUser.username });
  } else {
  // 失败：状态码400（客户端错误），返回错误信息
    res.status(400).json({ code: 400, message: '用户名或密码错误' });
}
  ```

- 常用 HTTP 状态码：

  - 200 OK：请求成功（默认）。
  - 400 Bad Request：客户端请求参数错误（如用户名密码不匹配）。
  - 404 Not Found：请求路径不存在。
  - 500 Internal Server Error：服务器内部逻辑错误。

## 四、服务器启动与配置

### 4.1 端口配置与启动

- 端口选择

  ：端口是服务器与客户端通信的 “门户”，需选择未被占用的端口（常见开发端口：3000、4000、5000），通过变量定义便于后续修改：

  ```javascript
const PORT = 3000; // 定义端口号
  // 启动服务器，监听指定端口
app.listen(PORT, () => {
    console.log(`服务器运行在 http://127.0.0.1:${PORT}`); // 启动成功提示
});
  ```

- **`app.listen()` 方法**：Express 服务器启动函数，第一个参数为端口号，第二个参数为回调函数（服务器启动成功后执行，常用于打印日志）。

### 4.2 本地地址说明

- `127.0.0.1`：本地回环地址，代表 “当前计算机”，仅能在本机访问，用于开发环境测试。
- 完整访问地址格式：`http://[IP地址]:[端口号]`（如 `http://127.0.0.1:3000`），若需外部设备访问，需使用本机局域网 IP（如 `192.168.1.100:3000`）。

## 五、数据安全基础（密码哈希存储）

### 5.1 密码存储风险

- 明文密码存储存在极大安全隐患（如数据库泄露导致密码直接暴露），需通过 “哈希算法” 将密码转换为不可逆的字符串（哈希值）存储。

### 5.2 SHA-256 哈希算法

- **特点**：SHA-256 是一种密码学哈希函数，可将任意长度的输入转换为 256 位（64 个十六进制字符）的输出，且无法通过哈希值反推原密码。
- **示例**：原密码 `a` 的 SHA-256 哈希值为 `ca978112ca1bbdcafac231b39a23dc4da786eff8147c4e72b9807785afee48bb`。
- **注意事项**：实际开发中，建议结合 “盐值（Salt）” 增强安全性（避免相同密码生成相同哈希值），可使用 `bcrypt`、`crypto-js` 等库实现。

## 六、关键 API 汇总

| 类别       | API 语法                      | 作用描述                                                     |
| ---------- | ----------------------------- | ------------------------------------------------------------ |
| 框架核心   | `express()`                   | 创建 Express 应用实例                                        |
| 中间件配置 | `app.use(middleware)`         | 注册中间件，作用于所有请求或指定路径请求                     |
| 路由定义   | `app.post(path, handler)`     | 定义 POST 方法的路由，处理对应路径的 POST 请求               |
| 请求处理   | `req.body`                    | 获取解析后的请求体数据（需配置解析中间件）                   |
| 响应发送   | `res.json(data)`              | 发送 JSON 格式响应                                           |
| 状态码设置 | `res.status(code).json(data)` | 设置 HTTP 状态码并发送 JSON 响应                             |
| 服务器启动 | `app.listen(port, callback)`  | 启动服务器，监听指定端口，回调函数在启动成功后执行           |
| 数组查询   | `array.find(callback)`        | 遍历数组，返回第一个满足回调函数条件的元素，无匹配则返回 undefined |



